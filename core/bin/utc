#!/bin/bash
# utc - fast version
# Shows current or specified UTC time in relevant countries/regions (24-hour format)
# DST-aware, sorted by local time

YELLOW="\033[1;33m"
RESET="\033[0m"

declare -A TIMEZONES=(
    ["USA East"]="America/New_York"
    ["USA West"]="America/Los_Angeles"
    ["Brazil"]="America/Sao_Paulo"
    ["UK"]="Europe/London"
    ["Germany"]="Europe/Berlin"
    ["France"]="Europe/Paris"
    ["Italy"]="Europe/Rome"
    ["Spain"]="Europe/Madrid"
    ["Greece"]="Europe/Athens"
    ["Netherlands"]="Europe/Amsterdam"
    ["Sweden"]="Europe/Stockholm"
    ["Norway"]="Europe/Oslo"
    ["Poland"]="Europe/Warsaw"
    ["Russia"]="Europe/Moscow"
    ["India"]="Asia/Kolkata"
    ["Japan"]="Asia/Tokyo"
    ["China"]="Asia/Shanghai"
    ["Australia"]="Australia/Sydney"
    ["South Africa"]="Africa/Johannesburg"
)

# Parse UTC input
parse_utc_time() {
    input="$1"
    input=$(echo "$input" | tr '[:upper:]' '[:lower:]' | tr -d ' .')

    if [[ "$input" =~ ^([0-9]{1,2})$ ]]; then
        printf "%02d:00\n" "${BASH_REMATCH[1]}"
    elif [[ "$input" =~ ^([0-9]{1,2}):([0-9]{2})$ ]]; then
        printf "%02d:%02d\n" "${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}"
    elif [[ "$input" =~ ^([0-9]{1,2})(am|pm)$ ]]; then
        hour=${BASH_REMATCH[1]}
        period=${BASH_REMATCH[2]}
        if [ "$period" == "pm" ] && [ "$hour" -lt 12 ]; then
            hour=$((hour + 12))
        elif [ "$period" == "am" ] && [ "$hour" -eq 12 ]; then
            hour=0
        fi
        printf "%02d:00\n" "$hour"
    else
        echo "Invalid UTC time format: $1" >&2
        exit 1
    fi
}

# Determine UTC and optional region
if [ $# -ge 1 ] && [[ "$1" =~ ^[0-9]{1,2}(:[0-9]{2})?([ap]m)?$ ]]; then
    UTC_ARG=$(parse_utc_time "$1")
    REGION_ARG="$2"
else
    UTC_ARG=$(date -u +"%H:%M")
    REGION_ARG="$1"
fi

echo -e "${YELLOW}üåç UTC World Clock (DST-aware) üåç${RESET}"
echo "---------------------------------"

# Prepare array for all results
declare -a results

for region in "${!TIMEZONES[@]}"; do
    # If a region filter is specified, skip non-matching regions
    if [ -n "$REGION_ARG" ]; then
        arg=$(echo "$REGION_ARG" | tr '[:upper:]' '[:lower:]')
        region_lower=$(echo "$region" | tr '[:upper:]' '[:lower:]')
        if [[ "$region_lower" != *"$arg"* ]]; then
            continue
        fi
    fi
    timezone="${TIMEZONES[$region]}"
    # Use one date call per region
    local_time=$(TZ="$timezone" date -d "$UTC_ARG UTC" +"%H:%M")
    sort_key=$(TZ="$timezone" date -d "$UTC_ARG UTC" +"%H%M")
    results+=("$sort_key|$region|$local_time")
done

# Sort results in memory and print
IFS=$'\n' sorted=($(sort -t'|' -k1,1n <<<"${results[*]}"))
unset IFS
for entry in "${sorted[@]}"; do
    IFS='|' read -r _ region local_time <<<"$entry"
    printf "%-15s : %s\n" "$region" "$local_time"
done
